// FB_HekBesturing.scl
// Toestandsmachine voor hekbesturing - 9 toestanden per FDS sectie 2.2
// Hoofdlogica voor automatisch hek met veiligheidsprioriteiten
//
// Toestanden (per DB_States):
// 0 = HOMING      - Zoeken referentiepositie bij opstart
// 1 = IDLE_OPEN   - Hek volledig open, motor uit
// 2 = IDLE_DICHT  - Hek volledig dicht, alarm aan
// 3 = MOVING_OPEN - Beweging richting open
// 4 = MOVING_DICHT- Beweging richting dicht
// 5 = STOPPED     - Gestopt in tussenpositie
// 6 = VS_PAUSE    - Gepauzeerd door lichtsluis
// 7 = PBV_RETRACT - Terugtrekken na bumperactivatie
// 8 = FAULT       - Sensorstoring gedetecteerd

FUNCTION_BLOCK "FB_HekBesturing"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1

   VAR_INPUT
      i_SS_Open : Bool;              // Sleutelschakelaar naar OPEN (1=contact)
      i_SS_Dicht : Bool;             // Sleutelschakelaar naar DICHT (1=contact)
      i_DK_Bediening : Bool;         // Drukknop bediening (NC: 0=ingedrukt)
      i_BNS_Open : Bool;             // Benaderingsschakelaar OPEN (NC: 0=bereikt)
      i_BNS_Dicht : Bool;            // Benaderingsschakelaar DICHT (NC: 0=bereikt)
      i_PBV_Trigger : Bool;          // PBV actief (van FC_Veiligheid)
      i_VS_Trigger : Bool;           // VS actief (van FC_Veiligheid)
      i_Fault : Bool;                // Sensordefect (van FC_Veiligheid)
   END_VAR

   VAR_OUTPUT
      q_MS_Open : Bool;              // Motor sturing richting OPEN
      q_MS_Dicht : Bool;             // Motor sturing richting DICHT
      q_MS_LaagToeren : Bool;        // Motor lage snelheid actief
      q_AlarmKerk : Bool;            // Kerkalarm (0=hek dicht, 1=hek niet dicht)
      q_HuidigeToestand : Int;       // Huidige toestand voor diagnose/HMI
   END_VAR

   VAR
      m_Toestand : Int;              // Huidige toestand van de state machine
      m_VorigeToestand : Int;        // Vorige toestand (voor transitie detectie)
      m_LaatsteRichting : Int;       // Laatst actieve richting (DIR_OPEN=1, DIR_DICHT=2)
      m_VorigeRichtingVoorVS : Int;  // Direction before VS pause (for auto-resume)

      // Edge detection - IEC standard function blocks
      m_EdgeSS_Open : R_TRIG;        // Rising edge key switch OPEN
      m_EdgeSS_Dicht : R_TRIG;       // Rising edge key switch DICHT
      m_EdgeDK : F_TRIG;             // Falling edge push button (NC: 0=pressed)

      // Timers
      m_TON_Timeout : TON;           // Movement timeout (90s per CFG_BewegingTimeoutS)
      m_TON_PBV_Retract : TON;       // PBV retract duration timer (3s per CFG_PBV_TerugtrekMs)

      // Control flags
      m_KeyReleased : Bool := TRUE;  // CTL-08: Key release tracking after timeout
      m_FirstScan : Bool := TRUE;    // Power-on detection for initialization
   END_VAR

BEGIN
    // =========================================================================
    // Edge detection - call BEFORE CASE statement (ensures edges detected once per scan)
    // =========================================================================
    #m_EdgeSS_Open(CLK := #i_SS_Open);
    #m_EdgeSS_Dicht(CLK := #i_SS_Dicht);
    #m_EdgeDK(CLK := #i_DK_Bediening);  // NC: falling edge = press

    // =========================================================================
    // Movement timeout timer - runs in HOMING, MOVING_OPEN, MOVING_DICHT
    // =========================================================================
    #m_TON_Timeout(IN := (#m_Toestand = "DB_States".STATE_HOMING) OR
                          (#m_Toestand = "DB_States".STATE_MOVING_OPEN) OR
                          (#m_Toestand = "DB_States".STATE_MOVING_DICHT),
                   PT := "DB_Config".Timers.CFG_BewegingTimeoutS);

    // =========================================================================
    // PBV retract timer - runs only in PBV_RETRACT state
    // =========================================================================
    #m_TON_PBV_Retract(IN := (#m_Toestand = "DB_States".STATE_PBV_RETRACT),
                       PT := "DB_Config".Timers.CFG_PBV_TerugtrekMs);

    // =========================================================================
    // Power-on initialization - determine initial state from endstops
    // =========================================================================
    IF #m_FirstScan THEN
        #m_FirstScan := FALSE;
        // NC sensors: 0 = reached, 1 = not reached
        IF (NOT #i_BNS_Open) AND (NOT #i_BNS_Dicht) THEN
            // Both endstops - sensor fault
            #m_Toestand := "DB_States".STATE_FAULT;
        ELSIF NOT #i_BNS_Dicht THEN
            // At DICHT position
            #m_Toestand := "DB_States".STATE_IDLE_DICHT;
        ELSIF NOT #i_BNS_Open THEN
            // At OPEN position
            #m_Toestand := "DB_States".STATE_IDLE_OPEN;
        ELSE
            // Neither endstop - unknown position, need homing
            #m_Toestand := "DB_States".STATE_HOMING;
        END_IF;
    END_IF;

    // =========================================================================
    // Save previous state (for transition detection in future plans)
    // =========================================================================
    #m_VorigeToestand := #m_Toestand;

    // =========================================================================
    // Main state machine CASE statement
    // =========================================================================
    CASE #m_Toestand OF
        "DB_States".STATE_HOMING:
            // HOMING: Moving toward DICHT to find reference position
            // Safety checks FIRST (priority: FAULT > PBV > VS per CONTEXT.md)
            IF #i_Fault THEN
                #m_Toestand := "DB_States".STATE_FAULT;
            ELSIF #i_PBV_Trigger OR #i_VS_Trigger THEN
                // SM-04: HOMING aborts to STOPPED on PBV or VS trigger
                #m_Toestand := "DB_States".STATE_STOPPED;
            ELSIF #m_TON_Timeout.Q THEN
                // SAF-12: HOMING uses same timeout as normal movement
                #m_Toestand := "DB_States".STATE_STOPPED;
                #m_KeyReleased := FALSE;
            ELSIF NOT #i_BNS_Dicht THEN
                // NC: 0 = reached DICHT endstop
                #m_Toestand := "DB_States".STATE_IDLE_DICHT;
            ELSIF #m_EdgeDK.Q THEN
                // Push button during HOMING -> abort to STOPPED (manual stop works in all movement states)
                #m_Toestand := "DB_States".STATE_STOPPED;
            END_IF;
            // Motor output: moving toward DICHT (handled in output section)

        "DB_States".STATE_IDLE_OPEN:
            // Gate fully OPEN, motor off
            // Clear direction memory when at endstop (no accidental resume toward wall)
            #m_LaatsteRichting := "DB_States".DIR_NONE;

            IF #i_Fault THEN
                #m_Toestand := "DB_States".STATE_FAULT;
            ELSIF #i_PBV_Trigger THEN
                // PBV at IDLE_OPEN: stay here (already at safest position per CONTEXT.md)
                ; // No action - already at OPEN endstop
            // Key DICHT starts movement toward DICHT
            ELSIF #m_EdgeSS_Dicht.Q THEN
                #m_Toestand := "DB_States".STATE_MOVING_DICHT;
                #m_LaatsteRichting := "DB_States".DIR_DICHT;
            END_IF;
            // No push button action from IDLE (no direction memory)

        "DB_States".STATE_IDLE_DICHT:
            // Gate fully CLOSED, motor off, alarm deactivated
            // Clear direction memory when at endstop
            #m_LaatsteRichting := "DB_States".DIR_NONE;

            IF #i_Fault THEN
                #m_Toestand := "DB_States".STATE_FAULT;
            // Key OPEN starts movement toward OPEN
            ELSIF #m_EdgeSS_Open.Q THEN
                #m_Toestand := "DB_States".STATE_MOVING_OPEN;
                #m_LaatsteRichting := "DB_States".DIR_OPEN;
            END_IF;
            // No push button action from IDLE (no direction memory)

        "DB_States".STATE_MOVING_OPEN:
            // Moving toward OPEN position
            // Safety checks FIRST (priority: FAULT > PBV > VS)
            IF #i_Fault THEN
                #m_Toestand := "DB_States".STATE_FAULT;
            ELSIF #i_PBV_Trigger THEN
                // PBV during OPEN movement -> retract (continues toward OPEN)
                #m_Toestand := "DB_States".STATE_PBV_RETRACT;
            ELSIF #i_VS_Trigger THEN
                // VS pause - save direction for auto-resume
                #m_VorigeRichtingVoorVS := "DB_States".DIR_OPEN;
                #m_Toestand := "DB_States".STATE_VS_PAUSE;
            ELSIF #m_TON_Timeout.Q THEN
                // SAF-11: Movement timeout -> STOPPED
                #m_Toestand := "DB_States".STATE_STOPPED;
                #m_KeyReleased := FALSE;  // CTL-08: require key release
            ELSIF NOT #i_BNS_Open THEN
                // NC: 0 = reached OPEN endstop
                #m_Toestand := "DB_States".STATE_IDLE_OPEN;
            ELSIF #m_EdgeDK.Q THEN
                // Push button -> manual stop
                #m_Toestand := "DB_States".STATE_STOPPED;
            ELSIF #m_EdgeSS_Dicht.Q THEN
                // CTL-07: Opposing key direction while moving -> stop
                #m_Toestand := "DB_States".STATE_STOPPED;
            END_IF;
            // Direction memory maintained (already set when entering this state)
            // Motor output: q_MS_Open=TRUE (handled in output section)

        "DB_States".STATE_MOVING_DICHT:
            // Moving toward DICHT (closed) position
            // Safety checks FIRST (priority: FAULT > PBV > VS)
            IF #i_Fault THEN
                #m_Toestand := "DB_States".STATE_FAULT;
            ELSIF #i_PBV_Trigger THEN
                // PBV during DICHT movement -> retract toward OPEN (SAF-03)
                #m_Toestand := "DB_States".STATE_PBV_RETRACT;
            ELSIF #i_VS_Trigger THEN
                // VS pause - save direction for auto-resume
                #m_VorigeRichtingVoorVS := "DB_States".DIR_DICHT;
                #m_Toestand := "DB_States".STATE_VS_PAUSE;
            ELSIF #m_TON_Timeout.Q THEN
                // SAF-11: Movement timeout -> STOPPED
                #m_Toestand := "DB_States".STATE_STOPPED;
                #m_KeyReleased := FALSE;  // CTL-08: require key release
            ELSIF NOT #i_BNS_Dicht THEN
                // NC: 0 = reached DICHT endstop
                #m_Toestand := "DB_States".STATE_IDLE_DICHT;
            ELSIF #m_EdgeDK.Q THEN
                // Push button -> manual stop
                #m_Toestand := "DB_States".STATE_STOPPED;
            ELSIF #m_EdgeSS_Open.Q THEN
                // CTL-07: Opposing key direction while moving -> stop
                #m_Toestand := "DB_States".STATE_STOPPED;
            END_IF;
            // Direction memory maintained (already set when entering this state)
            // Motor output: q_MS_Dicht=TRUE (handled in output section)

        "DB_States".STATE_STOPPED:
            // Stopped in intermediate position (not at endstop)
            // Motor outputs off (handled in output section)

            IF #i_Fault THEN
                #m_Toestand := "DB_States".STATE_FAULT;
            ELSE
                // CTL-08: Track key release after timeout
                // Keys must be released before new input is accepted
                IF NOT #m_KeyReleased THEN
                    // Waiting for key release after timeout
                    IF NOT #i_SS_Open AND NOT #i_SS_Dicht THEN
                        #m_KeyReleased := TRUE;
                    END_IF;
                    // Ignore all input while waiting for release
                ELSE
                    // Normal input processing
                    // CTL-06: Key switch from STOPPED starts in selected direction (overrides last direction)
                    IF #m_EdgeSS_Open.Q THEN
                        #m_Toestand := "DB_States".STATE_MOVING_OPEN;
                        #m_LaatsteRichting := "DB_States".DIR_OPEN;
                    ELSIF #m_EdgeSS_Dicht.Q THEN
                        #m_Toestand := "DB_States".STATE_MOVING_DICHT;
                        #m_LaatsteRichting := "DB_States".DIR_DICHT;
                    // CTL-04, CTL-05: Push button toggles stop/resume, resumes last direction
                    ELSIF #m_EdgeDK.Q THEN
                        IF #m_LaatsteRichting = "DB_States".DIR_OPEN THEN
                            #m_Toestand := "DB_States".STATE_MOVING_OPEN;
                        ELSIF #m_LaatsteRichting = "DB_States".DIR_DICHT THEN
                            #m_Toestand := "DB_States".STATE_MOVING_DICHT;
                        END_IF;
                        // If m_LaatsteRichting = DIR_NONE (fresh power-up, never moved)
                        // -> ignore push button (safest default per CONTEXT.md - no movement without explicit direction)
                    END_IF;
                END_IF;
            END_IF;

        "DB_States".STATE_VS_PAUSE:
            // Placeholder - Plan 03-03
            ;

        "DB_States".STATE_PBV_RETRACT:
            // Placeholder - Plan 03-03
            ;

        "DB_States".STATE_FAULT:
            // Sensor fault detected - both endstops active simultaneously
            // Motor outputs forced off (handled in output section)
            // Clear direction memory on FAULT (safety per CONTEXT.md - Claude decides)
            #m_LaatsteRichting := "DB_States".DIR_NONE;

            // Auto-recovery when fault condition clears (SM-08)
            IF NOT #i_Fault THEN
                // Check current sensor state to determine recovery state
                IF NOT #i_BNS_Dicht THEN
                    #m_Toestand := "DB_States".STATE_IDLE_DICHT;
                ELSIF NOT #i_BNS_Open THEN
                    #m_Toestand := "DB_States".STATE_IDLE_OPEN;
                ELSE
                    // Neither endstop - go to STOPPED (safe default per CONTEXT.md)
                    #m_Toestand := "DB_States".STATE_STOPPED;
                END_IF;
            END_IF;

        ELSE
            // Unexpected state - recover to safe state
            #m_Toestand := "DB_States".STATE_STOPPED;
    END_CASE;

    // =========================================================================
    // Motor outputs based on state (direction only, low speed in Phase 4)
    // =========================================================================
    CASE #m_Toestand OF
        "DB_States".STATE_MOVING_OPEN, "DB_States".STATE_PBV_RETRACT:
            #q_MS_Open := TRUE;
            #q_MS_Dicht := FALSE;

        "DB_States".STATE_MOVING_DICHT, "DB_States".STATE_HOMING:
            #q_MS_Open := FALSE;
            #q_MS_Dicht := TRUE;

        ELSE
            #q_MS_Open := FALSE;
            #q_MS_Dicht := FALSE;
    END_CASE;

    // Low speed placeholder (Phase 4)
    #q_MS_LaagToeren := FALSE;

    // Alarm: only deactivated (0) when in IDLE_DICHT
    #q_AlarmKerk := NOT (#m_Toestand = "DB_States".STATE_IDLE_DICHT);

    // Diagnostic output
    #q_HuidigeToestand := #m_Toestand;

END_FUNCTION_BLOCK
