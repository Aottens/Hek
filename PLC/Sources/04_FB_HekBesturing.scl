// FB_HekBesturing.scl
// Toestandsmachine voor hekbesturing - 9 toestanden per FDS sectie 2.2
// Hoofdlogica voor automatisch hek met veiligheidsprioriteiten
//
// Toestanden (per DB_States):
// 0 = HOMING      - Zoeken referentiepositie bij opstart
// 1 = IDLE_OPEN   - Hek volledig open, motor uit
// 2 = IDLE_DICHT  - Hek volledig dicht, alarm aan
// 3 = MOVING_OPEN - Beweging richting open
// 4 = MOVING_DICHT- Beweging richting dicht
// 5 = STOPPED     - Gestopt in tussenpositie
// 6 = VS_PAUSE    - Gepauzeerd door lichtsluis
// 7 = PBV_RETRACT - Terugtrekken na bumperactivatie
// 8 = FAULT       - Sensorstoring gedetecteerd

FUNCTION_BLOCK "FB_HekBesturing"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1

   VAR_INPUT
      i_SS_Open : Bool;              // Sleutelschakelaar naar OPEN (1=contact)
      i_SS_Dicht : Bool;             // Sleutelschakelaar naar DICHT (1=contact)
      i_DK_Bediening : Bool;         // Drukknop bediening (NC: 0=ingedrukt)
      i_BNS_Open : Bool;             // Benaderingsschakelaar OPEN (NC: 0=bereikt)
      i_BNS_Dicht : Bool;            // Benaderingsschakelaar DICHT (NC: 0=bereikt)
      i_PBV_Trigger : Bool;          // PBV actief (van FC_Veiligheid)
      i_VS_Trigger : Bool;           // VS actief (van FC_Veiligheid)
      i_Fault : Bool;                // Sensordefect (van FC_Veiligheid)
   END_VAR

   VAR_OUTPUT
      q_MS_Open : Bool;              // Motor sturing richting OPEN
      q_MS_Dicht : Bool;             // Motor sturing richting DICHT
      q_MS_LaagToeren : Bool;        // Motor lage snelheid actief
      q_AlarmKerk : Bool;            // Kerkalarm (0=hek dicht, 1=hek niet dicht)
      q_HuidigeToestand : Int;       // Huidige toestand voor diagnose/HMI
   END_VAR

   VAR
      m_Toestand : Int;              // Huidige toestand van de state machine
      m_VorigeToestand : Int;        // Vorige toestand (voor transitie detectie)
      m_LaatsteRichting : Int;       // Laatst actieve richting (DIR_OPEN=1, DIR_DICHT=2)
      m_VorigeRichtingVoorVS : Int;  // Direction before VS pause (for auto-resume)

      // Edge detection - IEC standard function blocks
      m_EdgeSS_Open : R_TRIG;        // Rising edge key switch OPEN
      m_EdgeSS_Dicht : R_TRIG;       // Rising edge key switch DICHT
      m_EdgeDK : F_TRIG;             // Falling edge push button (NC: 0=pressed)

      // Timers
      m_TON_Timeout : TON;           // Movement timeout (90s per CFG_BewegingTimeoutS)

      // Control flags
      m_KeyReleased : Bool := TRUE;  // CTL-08: Key release tracking after timeout
      m_FirstScan : Bool := TRUE;    // Power-on detection for initialization
   END_VAR

BEGIN
    // =========================================================================
    // Edge detection - call BEFORE CASE statement (ensures edges detected once per scan)
    // =========================================================================
    #m_EdgeSS_Open(CLK := #i_SS_Open);
    #m_EdgeSS_Dicht(CLK := #i_SS_Dicht);
    #m_EdgeDK(CLK := #i_DK_Bediening);  // NC: falling edge = press

    // =========================================================================
    // Movement timeout timer - runs in HOMING, MOVING_OPEN, MOVING_DICHT
    // =========================================================================
    #m_TON_Timeout(IN := (#m_Toestand = "DB_States".STATE_HOMING) OR
                          (#m_Toestand = "DB_States".STATE_MOVING_OPEN) OR
                          (#m_Toestand = "DB_States".STATE_MOVING_DICHT),
                   PT := "DB_Config".Timers.CFG_BewegingTimeoutS);

    // =========================================================================
    // Power-on initialization - determine initial state from endstops
    // =========================================================================
    IF #m_FirstScan THEN
        #m_FirstScan := FALSE;
        // NC sensors: 0 = reached, 1 = not reached
        IF (NOT #i_BNS_Open) AND (NOT #i_BNS_Dicht) THEN
            // Both endstops - sensor fault
            #m_Toestand := "DB_States".STATE_FAULT;
        ELSIF NOT #i_BNS_Dicht THEN
            // At DICHT position
            #m_Toestand := "DB_States".STATE_IDLE_DICHT;
        ELSIF NOT #i_BNS_Open THEN
            // At OPEN position
            #m_Toestand := "DB_States".STATE_IDLE_OPEN;
        ELSE
            // Neither endstop - unknown position, need homing
            #m_Toestand := "DB_States".STATE_HOMING;
        END_IF;
    END_IF;

    // =========================================================================
    // Save previous state (for transition detection in future plans)
    // =========================================================================
    #m_VorigeToestand := #m_Toestand;

    // =========================================================================
    // Main state machine CASE statement
    // =========================================================================
    CASE #m_Toestand OF
        "DB_States".STATE_HOMING:
            // Implemented in this plan (Task 3)
            ;

        "DB_States".STATE_IDLE_OPEN:
            // Implemented in this plan (Task 3)
            ;

        "DB_States".STATE_IDLE_DICHT:
            // Implemented in this plan (Task 3)
            ;

        "DB_States".STATE_MOVING_OPEN:
            // Placeholder - Plan 03-02
            ;

        "DB_States".STATE_MOVING_DICHT:
            // Placeholder - Plan 03-02
            ;

        "DB_States".STATE_STOPPED:
            // Placeholder - Plan 03-02
            ;

        "DB_States".STATE_VS_PAUSE:
            // Placeholder - Plan 03-03
            ;

        "DB_States".STATE_PBV_RETRACT:
            // Placeholder - Plan 03-03
            ;

        "DB_States".STATE_FAULT:
            // Implemented in this plan (Task 3)
            ;

        ELSE
            // Unexpected state - recover to safe state
            #m_Toestand := "DB_States".STATE_STOPPED;
    END_CASE;

    // =========================================================================
    // Motor outputs based on state (direction only, low speed in Phase 4)
    // =========================================================================
    CASE #m_Toestand OF
        "DB_States".STATE_MOVING_OPEN, "DB_States".STATE_PBV_RETRACT:
            #q_MS_Open := TRUE;
            #q_MS_Dicht := FALSE;

        "DB_States".STATE_MOVING_DICHT, "DB_States".STATE_HOMING:
            #q_MS_Open := FALSE;
            #q_MS_Dicht := TRUE;

        ELSE
            #q_MS_Open := FALSE;
            #q_MS_Dicht := FALSE;
    END_CASE;

    // Low speed placeholder (Phase 4)
    #q_MS_LaagToeren := FALSE;

    // Alarm: only deactivated (0) when in IDLE_DICHT
    #q_AlarmKerk := NOT (#m_Toestand = "DB_States".STATE_IDLE_DICHT);

    // Diagnostic output
    #q_HuidigeToestand := #m_Toestand;

END_FUNCTION_BLOCK
