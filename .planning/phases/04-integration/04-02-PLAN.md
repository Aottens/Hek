---
phase: 04-integration
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - PLC/Sources/04_FB_HekBesturing.scl
  - PLC/Sources/06_FC_Outputs.scl
autonomous: true

must_haves:
  truths:
    - "VS_PAUSE waits CFG_VS_HervattingMs (2s) after beam clears before resuming"
    - "PBV_RETRACT waits CFG_PBV_PauzeMs (500ms) before starting retract movement"
    - "Motor outputs are mutually exclusive (never both q_MS_Open and q_MS_Dicht active)"
    - "If both motor directions requested, FC_Outputs blocks BOTH (fail-safe)"
  artifacts:
    - path: "PLC/Sources/04_FB_HekBesturing.scl"
      provides: "Updated VS_PAUSE and PBV_RETRACT states with timers"
      contains: "m_VS_ResumeDelayDone"
    - path: "PLC/Sources/06_FC_Outputs.scl"
      provides: "Mutual exclusion safety check"
      contains: "i_MS_Open AND i_MS_Dicht"
  key_links:
    - from: "m_TON_VS_Hervatting.Q"
      to: "VS_PAUSE transition"
      via: "Resume delay gate"
      pattern: "m_VS_ResumeDelayDone"
    - from: "FC_Outputs"
      to: "Motor outputs"
      via: "Mutual exclusion check"
      pattern: "IF.*i_MS_Open AND.*i_MS_Dicht"
---

<objective>
Update VS_PAUSE and PBV_RETRACT states to use timers, and add mutual exclusion to FC_Outputs.

Purpose: Implement TMR-02, TMR-04, OUT-05 - VS resume delay, PBV pause before retract, motor mutual exclusion.

Output: Complete Phase 4 integration with all timer sequences and safety outputs.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-integration/04-RESEARCH.md
@.planning/phases/04-integration/04-01-SUMMARY.md
@PLC/Sources/04_FB_HekBesturing.scl
@PLC/Sources/06_FC_Outputs.scl
@PLC/Sources/02_DB_Config.scl
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update VS_PAUSE state with resume delay</name>
  <files>PLC/Sources/04_FB_HekBesturing.scl</files>
  <action>
Modify the STATE_VS_PAUSE case to use the resume delay timer (m_VS_ResumeDelayDone from Plan 04-01).

Current VS_PAUSE resumes immediately when beam clears. Update to:

```
"DB_States".STATE_VS_PAUSE:
    // Paused due to vehicle sensor (beam blocked)
    // SAF-08: Auto-resumes in same direction after beam clear + CFG_VS_HervattingMs delay
    // SAF-09: Ignores operator input during pause (auto-resume has priority)

    // Safety checks FIRST (priority: FAULT > PBV > VS)
    IF #i_Fault THEN
        #m_Toestand := "DB_States".STATE_FAULT;
    ELSIF #i_PBV_Trigger THEN
        // PBV > VS: PBV can interrupt VS_PAUSE
        #m_Toestand := "DB_States".STATE_PBV_RETRACT;
        #m_PBV_Retracting := FALSE;  // Start fresh - pause phase first
    ELSIF NOT #i_VS_Trigger THEN
        // Beam cleared - wait for resume delay (TMR-04)
        // m_TON_VS_Hervatting runs in timer section when in this state AND beam clear
        IF #m_VS_ResumeDelayDone THEN
            // TMR-04 complete: resume movement with VS low speed flag
            #m_VS_ResumeActive := TRUE;  // Enables VS low speed timer
            IF #m_VorigeRichtingVoorVS = "DB_States".DIR_OPEN THEN
                #m_Toestand := "DB_States".STATE_MOVING_OPEN;
            ELSIF #m_VorigeRichtingVoorVS = "DB_States".DIR_DICHT THEN
                #m_Toestand := "DB_States".STATE_MOVING_DICHT;
            ELSE
                // Safety fallback: no saved direction -> go to STOPPED
                #m_Toestand := "DB_States".STATE_STOPPED;
            END_IF;
        END_IF;
        // Note: If beam re-triggers during delay, TON resets (IN goes FALSE)
    END_IF;
    // Operator input ignored (SAF-09) - no key/push button checks
```

Key changes from Phase 3:
- Added check for m_VS_ResumeDelayDone before resuming (was: immediate resume)
- Added m_VS_ResumeActive := TRUE to enable VS low speed timer
- Added m_PBV_Retracting := FALSE when transitioning to PBV_RETRACT
  </action>
  <verify>
Grep for "m_VS_ResumeDelayDone" in VS_PAUSE section - should show delay check before resume.
  </verify>
  <done>
VS_PAUSE waits CFG_VS_HervattingMs (2s default) after beam clears before resuming. VS low speed flag set on resume.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update PBV_RETRACT state with pause before movement</name>
  <files>PLC/Sources/04_FB_HekBesturing.scl</files>
  <action>
Modify STATE_PBV_RETRACT to implement two-phase behavior:
1. Pause phase: Wait CFG_PBV_PauzeMs (500ms) before starting movement
2. Retract phase: Move toward OPEN for max CFG_PBV_TerugtrekMs or until endstop

Use m_PBV_Retracting flag (added in Plan 04-01) to track phase:
- FALSE = in pause phase (waiting for m_PBV_PauseDone)
- TRUE = in retract phase (motor active, checking m_TON_PBV_Retract)

```
"DB_States".STATE_PBV_RETRACT:
    // Retracting toward OPEN after bumper activation
    // SAF-03: Always moves toward OPEN regardless of previous direction
    // SAF-05: Ignores ALL operator input during retract
    // TMR-02: Wait CFG_PBV_PauzeMs before starting movement
    // TMR-03: Max retract duration CFG_PBV_TerugtrekMs

    // Only FAULT can interrupt PBV_RETRACT (FAULT > PBV priority)
    IF #i_Fault THEN
        #m_Toestand := "DB_States".STATE_FAULT;
        #m_PBV_Retracting := FALSE;  // Reset for next time
    ELSIF NOT #m_PBV_Retracting THEN
        // PAUSE PHASE: Waiting before retract (TMR-02)
        // m_TON_PBV_Pauze runs in timer section when in this state AND NOT m_PBV_Retracting
        IF #m_PBV_PauseDone THEN
            // Pause complete - start retract movement
            #m_PBV_Retracting := TRUE;
        END_IF;
        // Motor outputs are OFF during pause (handled in output section)
    ELSE
        // RETRACT PHASE: Moving toward OPEN (motor active)
        IF NOT #i_BNS_Open THEN
            // NC: 0 = reached OPEN endstop -> safest position achieved
            #m_Toestand := "DB_States".STATE_IDLE_OPEN;
            #m_PBV_Retracting := FALSE;  // Reset for next time
        ELSIF #m_TON_PBV_Retract.Q THEN
            // SAF-04: Max retract duration reached, still in mid-position
            #m_Toestand := "DB_States".STATE_STOPPED;
            #m_LaatsteRichting := "DB_States".DIR_NONE;  // Clear direction memory
            #m_PBV_Retracting := FALSE;  // Reset for next time
        END_IF;
    END_IF;
    // Push button and key switch edges IGNORED in this state (SAF-05)
```

Also update the motor output CASE section to only output during retract phase:
```
"DB_States".STATE_PBV_RETRACT:
    // Only output motor during retract phase (after pause)
    IF #m_PBV_Retracting THEN
        #q_MS_Open := TRUE;
        #q_MS_Dicht := FALSE;
    ELSE
        // Pause phase - motor off
        #q_MS_Open := FALSE;
        #q_MS_Dicht := FALSE;
    END_IF;
```

Update existing m_TON_PBV_Retract timer to only run during retract phase:
```
#m_TON_PBV_Retract(IN := (#m_Toestand = "DB_States".STATE_PBV_RETRACT) AND #m_PBV_Retracting,
                   PT := "DB_Config".Timers.CFG_PBV_TerugtrekMs);
```
  </action>
  <verify>
Grep for "m_PBV_Retracting" in PBV_RETRACT section - should show two-phase logic.
  </verify>
  <done>
PBV_RETRACT waits CFG_PBV_PauzeMs (500ms default) before starting retract movement. Motor only active during retract phase.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add mutual exclusion to FC_Outputs</name>
  <files>PLC/Sources/06_FC_Outputs.scl</files>
  <action>
Replace the stub implementation with defensive mutual exclusion logic per OUT-05:

```
FUNCTION "FC_Outputs" : Void
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.2

   VAR_INPUT
      i_HuidigeToestand : Int;       // Huidige toestand van FB_HekBesturing
      i_MS_Open : Bool;              // Motor open commando
      i_MS_Dicht : Bool;             // Motor dicht commando
      i_MS_LaagToeren : Bool;        // Lage snelheid commando
      i_AlarmKerk : Bool;            // Alarm commando
   END_VAR

   VAR_OUTPUT
      q_MS_Open : Bool;              // %Q0.4 Motor sturing richting OPEN
      q_MS_Dicht : Bool;             // %Q0.5 Motor sturing richting DICHT
      q_MS_LaagToeren : Bool;        // %Q0.6 Motor lage snelheid
      q_AlarmKerk : Bool;            // %Q0.3 Kerkalarm
   END_VAR

BEGIN
    // =========================================================================
    // OUT-05: Motor outputs mutually exclusive (defensive check)
    // =========================================================================
    // Defense in depth: Even if FB sends invalid combination, FC blocks BOTH
    // This catches any logic bugs in state machine that could damage motor
    IF #i_MS_Open AND #i_MS_Dicht THEN
        // SAFETY: Both requested = bug in FB, fail-safe -> stop motor
        #q_MS_Open := FALSE;
        #q_MS_Dicht := FALSE;
        #q_MS_LaagToeren := FALSE;  // Also disable low speed for safety
    ELSE
        // Normal operation - pass through commands
        #q_MS_Open := #i_MS_Open;
        #q_MS_Dicht := #i_MS_Dicht;
        #q_MS_LaagToeren := #i_MS_LaagToeren;
    END_IF;

    // =========================================================================
    // OUT-04: Alarm output (fail-safe: 0 = hek dicht = alarm active)
    // =========================================================================
    // FB computes: TRUE when not in IDLE_DICHT
    // FC passes through - fail-safe is inherent (PLC off = output 0 = alarm on)
    #q_AlarmKerk := #i_AlarmKerk;

END_FUNCTION
```

Key points:
- If both i_MS_Open AND i_MS_Dicht are TRUE (bug), block BOTH outputs
- Also block low speed when in error state (motor stopped anyway)
- Alarm output passed through unchanged (fail-safe logic already correct)
- Version bumped to 0.2
  </action>
  <verify>
Grep for "i_MS_Open AND i_MS_Dicht" in FC_Outputs.scl - should show mutual exclusion check.
  </verify>
  <done>
FC_Outputs implements OUT-05 mutual exclusion. If both motor directions requested (bug), both blocked for fail-safe behavior.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. VS_PAUSE uses resume delay:
   - grep "m_VS_ResumeDelayDone" in VS_PAUSE -> shows delay check
   - grep "m_VS_ResumeActive := TRUE" -> shows VS low speed flag set

2. PBV_RETRACT two-phase behavior:
   - grep "m_PBV_Retracting" in PBV_RETRACT -> shows phase tracking
   - grep "m_PBV_PauseDone" -> shows pause phase check

3. FC_Outputs mutual exclusion:
   - grep "i_MS_Open AND i_MS_Dicht" -> shows defensive check
   - grep "q_MS_Open := FALSE" in same IF block -> shows fail-safe response

4. All requirements coverage:
   - TMR-01: Low speed timer (Plan 04-01)
   - TMR-02: PBV pause timer (this plan, Task 2)
   - TMR-03: PBV retract timer (existing, updated)
   - TMR-04: VS resume delay (this plan, Task 1)
   - TMR-05: VS low speed timer (Plan 04-01)
   - TMR-06: Movement timeout (existing from Phase 3)
   - TMR-07: Endstop debounce (existing from Phase 2)
   - TMR-08: Low speed pause/reset (Plan 04-01)
   - TMR-09: Timers outside CASE (Plan 04-01)
   - OUT-01 through OUT-06 (existing + this plan mutual exclusion)
</verification>

<success_criteria>
- [ ] VS_PAUSE waits for m_VS_ResumeDelayDone before resuming
- [ ] VS_PAUSE sets m_VS_ResumeActive flag on resume
- [ ] PBV_RETRACT has pause phase (motor off) and retract phase (motor on)
- [ ] PBV_RETRACT motor only active when m_PBV_Retracting = TRUE
- [ ] FC_Outputs checks for both motor directions and blocks both if true
- [ ] FC_Outputs version bumped to 0.2
- [ ] All TMR-* and OUT-* requirements satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/04-integration/04-02-SUMMARY.md`
</output>
