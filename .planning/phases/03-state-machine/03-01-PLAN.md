---
phase: 03-state-machine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - PLC/Sources/04_FB_HekBesturing.scl
autonomous: true

must_haves:
  truths:
    - "Power-on at DICHT endstop results in IDLE_DICHT state"
    - "Power-on at OPEN endstop results in IDLE_OPEN state"
    - "Power-on with neither endstop active results in HOMING state"
    - "Power-on with both endstops active results in FAULT state"
    - "HOMING moves toward DICHT and reaches IDLE_DICHT when endstop hit"
    - "HOMING aborts to STOPPED when PBV or VS trigger detected"
    - "FAULT state auto-recovers when sensor condition clears"
  artifacts:
    - path: "PLC/Sources/04_FB_HekBesturing.scl"
      provides: "Core state machine with initialization, HOMING, IDLE, FAULT"
      contains: "CASE #m_Toestand OF"
  key_links:
    - from: "FB_HekBesturing"
      to: "DB_States"
      via: "State constant references"
      pattern: '"DB_States"\\.STATE_'
    - from: "FB_HekBesturing"
      to: "i_Fault input"
      via: "FAULT state transition"
      pattern: "IF #i_Fault THEN"
---

<objective>
Implement core state machine structure in FB_HekBesturing with initialization logic, HOMING state, IDLE states, and FAULT state with auto-recovery.

Purpose: Establish the foundation for all state machine behavior - power-on detection, initial state determination, and fault handling that all other states depend on.

Output: FB_HekBesturing.scl with working CASE statement, edge detection variables, timeout timer, and the HOMING/IDLE/FAULT states fully implemented.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-state-machine/03-CONTEXT.md
@.planning/phases/03-state-machine/03-RESEARCH.md

# Current source files
@PLC/Sources/04_FB_HekBesturing.scl
@PLC/Sources/01_DB_States.scl
@PLC/Sources/02_DB_Config.scl
@statemachine.mmd
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add static variables for edge detection and timers</name>
  <files>PLC/Sources/04_FB_HekBesturing.scl</files>
  <action>
Add required static variables to the VAR section of FB_HekBesturing:

```scl
VAR
   m_Toestand : Int;              // Huidige toestand (existing)
   m_VorigeToestand : Int;        // Vorige toestand (existing)
   m_LaatsteRichting : Int;       // Laatst actieve richting (existing)
   m_VorigeRichtingVoorVS : Int;  // Direction before VS pause (for auto-resume)

   // Edge detection - IEC standard function blocks
   m_EdgeSS_Open : R_TRIG;        // Rising edge key switch OPEN
   m_EdgeSS_Dicht : R_TRIG;       // Rising edge key switch DICHT
   m_EdgeDK : F_TRIG;             // Falling edge push button (NC: 0=pressed)

   // Timers
   m_TON_Timeout : TON;           // Movement timeout (90s per CFG_BewegingTimeoutS)

   // Control flags
   m_KeyReleased : Bool := TRUE;  // CTL-08: Key release tracking after timeout
   m_FirstScan : Bool := TRUE;    // Power-on detection for initialization
END_VAR
```

The m_FirstScan variable (initialized TRUE) will be used to detect first scan and determine initial state. R_TRIG/F_TRIG are standard IEC function blocks that persist their state.
  </action>
  <verify>File compiles with no syntax errors when checked (TIA Portal import or manual review of SCL syntax)</verify>
  <done>FB_HekBesturing VAR section contains m_EdgeSS_Open, m_EdgeSS_Dicht, m_EdgeDK, m_TON_Timeout, m_VorigeRichtingVoorVS, m_KeyReleased, m_FirstScan</done>
</task>

<task type="auto">
  <name>Task 2: Implement initialization and CASE skeleton with edge detection</name>
  <files>PLC/Sources/04_FB_HekBesturing.scl</files>
  <action>
Replace the stub BEGIN...END_FUNCTION_BLOCK with full implementation structure:

1. **Edge detection calls FIRST** (before CASE - ensures edges detected once per scan):
```scl
// Edge detection - call BEFORE CASE statement
#m_EdgeSS_Open(CLK := #i_SS_Open);
#m_EdgeSS_Dicht(CLK := #i_SS_Dicht);
#m_EdgeDK(CLK := #i_DK_Bediening);  // NC: falling edge = press
```

2. **Timeout timer calculation** (runs when in movement states):
```scl
// Movement timeout timer - runs in HOMING, MOVING_OPEN, MOVING_DICHT
#m_TON_Timeout(IN := (#m_Toestand = "DB_States".STATE_HOMING) OR
                      (#m_Toestand = "DB_States".STATE_MOVING_OPEN) OR
                      (#m_Toestand = "DB_States".STATE_MOVING_DICHT),
               PT := "DB_Config".Timers.CFG_BewegingTimeoutS);
```

3. **First scan initialization**:
```scl
// Power-on initialization - determine initial state from endstops
IF #m_FirstScan THEN
    #m_FirstScan := FALSE;
    // NC sensors: 0 = reached, 1 = not reached
    IF (NOT #i_BNS_Open) AND (NOT #i_BNS_Dicht) THEN
        // Both endstops - sensor fault
        #m_Toestand := "DB_States".STATE_FAULT;
    ELSIF NOT #i_BNS_Dicht THEN
        // At DICHT position
        #m_Toestand := "DB_States".STATE_IDLE_DICHT;
    ELSIF NOT #i_BNS_Open THEN
        // At OPEN position
        #m_Toestand := "DB_States".STATE_IDLE_OPEN;
    ELSE
        // Neither endstop - unknown position, need homing
        #m_Toestand := "DB_States".STATE_HOMING;
    END_IF;
END_IF;
```

4. **Save previous state**:
```scl
#m_VorigeToestand := #m_Toestand;
```

5. **Main CASE skeleton** with ELSE fallback:
```scl
CASE #m_Toestand OF
    "DB_States".STATE_HOMING:
        // Implemented in this plan

    "DB_States".STATE_IDLE_OPEN:
        // Implemented in this plan

    "DB_States".STATE_IDLE_DICHT:
        // Implemented in this plan

    "DB_States".STATE_MOVING_OPEN:
        // Placeholder - Plan 03-02

    "DB_States".STATE_MOVING_DICHT:
        // Placeholder - Plan 03-02

    "DB_States".STATE_STOPPED:
        // Placeholder - Plan 03-02

    "DB_States".STATE_VS_PAUSE:
        // Placeholder - Plan 03-03

    "DB_States".STATE_PBV_RETRACT:
        // Placeholder - Plan 03-03

    "DB_States".STATE_FAULT:
        // Implemented in this plan

    ELSE
        // Unexpected state - recover to safe state
        #m_Toestand := "DB_States".STATE_STOPPED;
END_CASE;
```

6. **Output assignments after CASE** (partial - motor outputs only):
```scl
// Motor outputs based on state (direction only, low speed in Phase 4)
CASE #m_Toestand OF
    "DB_States".STATE_MOVING_OPEN, "DB_States".STATE_PBV_RETRACT:
        #q_MS_Open := TRUE;
        #q_MS_Dicht := FALSE;

    "DB_States".STATE_MOVING_DICHT, "DB_States".STATE_HOMING:
        #q_MS_Open := FALSE;
        #q_MS_Dicht := TRUE;

    ELSE
        #q_MS_Open := FALSE;
        #q_MS_Dicht := FALSE;
END_CASE;

// Low speed placeholder (Phase 4)
#q_MS_LaagToeren := FALSE;

// Alarm: only deactivated (0) when in IDLE_DICHT
#q_AlarmKerk := NOT (#m_Toestand = "DB_States".STATE_IDLE_DICHT);

// Diagnostic output
#q_HuidigeToestand := #m_Toestand;
```

NOTE: Put the m_VorigeToestand assignment AFTER the initialization check but BEFORE the CASE, so first scan sets state, then next scan detects no transition.
  </action>
  <verify>Review code structure: edge detection before CASE, initialization before CASE, CASE with all 9 states, output assignment after CASE</verify>
  <done>FB_HekBesturing has complete code skeleton with edge detection, initialization, CASE statement for all 9 states, and output assignments</done>
</task>

<task type="auto">
  <name>Task 3: Implement HOMING, IDLE, and FAULT state logic</name>
  <files>PLC/Sources/04_FB_HekBesturing.scl</files>
  <action>
Fill in the state logic for HOMING, IDLE_OPEN, IDLE_DICHT, and FAULT within the CASE statement:

**STATE_HOMING:**
```scl
"DB_States".STATE_HOMING:
    // HOMING: Moving toward DICHT to find reference position
    // Safety checks FIRST (priority: FAULT > PBV > VS per CONTEXT.md)
    IF #i_Fault THEN
        #m_Toestand := "DB_States".STATE_FAULT;
    ELSIF #i_PBV_Trigger OR #i_VS_Trigger THEN
        // SM-04: HOMING aborts to STOPPED on PBV or VS trigger
        #m_Toestand := "DB_States".STATE_STOPPED;
    ELSIF #m_TON_Timeout.Q THEN
        // SAF-12: HOMING uses same timeout as normal movement
        #m_Toestand := "DB_States".STATE_STOPPED;
        #m_KeyReleased := FALSE;
    ELSIF NOT #i_BNS_Dicht THEN
        // NC: 0 = reached DICHT endstop
        #m_Toestand := "DB_States".STATE_IDLE_DICHT;
    ELSIF #m_EdgeDK.Q THEN
        // Push button during HOMING -> abort to STOPPED (manual stop works in all movement states)
        #m_Toestand := "DB_States".STATE_STOPPED;
    END_IF;
    // Motor output: moving toward DICHT (handled in output section)
```

**STATE_IDLE_OPEN:**
```scl
"DB_States".STATE_IDLE_OPEN:
    // Gate fully OPEN, motor off
    // Clear direction memory when at endstop (no accidental resume toward wall)
    #m_LaatsteRichting := "DB_States".DIR_NONE;

    IF #i_Fault THEN
        #m_Toestand := "DB_States".STATE_FAULT;
    ELSIF #i_PBV_Trigger THEN
        // PBV at IDLE_OPEN: stay here (already at safest position per CONTEXT.md)
        ; // No action - already at OPEN endstop
    // Key DICHT starts movement toward DICHT
    ELSIF #m_EdgeSS_Dicht.Q THEN
        #m_Toestand := "DB_States".STATE_MOVING_DICHT;
        #m_LaatsteRichting := "DB_States".DIR_DICHT;
    END_IF;
    // No push button action from IDLE (no direction memory)
```

**STATE_IDLE_DICHT:**
```scl
"DB_States".STATE_IDLE_DICHT:
    // Gate fully CLOSED, motor off, alarm deactivated
    // Clear direction memory when at endstop
    #m_LaatsteRichting := "DB_States".DIR_NONE;

    IF #i_Fault THEN
        #m_Toestand := "DB_States".STATE_FAULT;
    // Key OPEN starts movement toward OPEN
    ELSIF #m_EdgeSS_Open.Q THEN
        #m_Toestand := "DB_States".STATE_MOVING_OPEN;
        #m_LaatsteRichting := "DB_States".DIR_OPEN;
    END_IF;
    // No push button action from IDLE (no direction memory)
```

**STATE_FAULT:**
```scl
"DB_States".STATE_FAULT:
    // Sensor fault detected - both endstops active simultaneously
    // Motor outputs forced off (handled in output section)
    // Clear direction memory on FAULT (safety per CONTEXT.md - Claude decides)
    #m_LaatsteRichting := "DB_States".DIR_NONE;

    // Auto-recovery when fault condition clears (SM-08)
    IF NOT #i_Fault THEN
        // Check current sensor state to determine recovery state
        IF NOT #i_BNS_Dicht THEN
            #m_Toestand := "DB_States".STATE_IDLE_DICHT;
        ELSIF NOT #i_BNS_Open THEN
            #m_Toestand := "DB_States".STATE_IDLE_OPEN;
        ELSE
            // Neither endstop - go to STOPPED (safe default per CONTEXT.md)
            #m_Toestand := "DB_States".STATE_STOPPED;
        END_IF;
    END_IF;
```

Safety logic note: i_Fault, i_PBV_Trigger, and i_VS_Trigger come from FB_Veiligheid with priority masking already applied. We still check FAULT first in each state as a defense-in-depth pattern.
  </action>
  <verify>Review each state: HOMING has safety checks + timeout + endstop + push button abort; IDLE states clear direction and handle key switch; FAULT clears direction and auto-recovers</verify>
  <done>HOMING transitions to IDLE_DICHT on endstop, STOPPED on safety/timeout/push button; IDLE states respond to key switch; FAULT auto-recovers based on sensor state</done>
</task>

</tasks>

<verification>
After all tasks complete, verify the following behaviors are possible:

1. **Initialization test cases:**
   - With i_BNS_Dicht=0 (NC reached) -> starts in STATE_IDLE_DICHT (value 2)
   - With i_BNS_Open=0 (NC reached) -> starts in STATE_IDLE_OPEN (value 1)
   - With both endstops=1 (neither reached) -> starts in STATE_HOMING (value 0)
   - With both endstops=0 (both reached) -> starts in STATE_FAULT (value 8)

2. **HOMING behavior:**
   - Motor output q_MS_Dicht=TRUE while in HOMING
   - Transitions to IDLE_DICHT when i_BNS_Dicht=0
   - Transitions to STOPPED when i_PBV_Trigger=TRUE or i_VS_Trigger=TRUE
   - Transitions to FAULT when i_Fault=TRUE

3. **IDLE state behavior:**
   - From IDLE_DICHT, key OPEN edge -> MOVING_OPEN
   - From IDLE_OPEN, key DICHT edge -> MOVING_DICHT
   - m_LaatsteRichting cleared when in IDLE states

4. **FAULT behavior:**
   - Motor outputs both FALSE in FAULT
   - Auto-recovers to IDLE_DICHT, IDLE_OPEN, or STOPPED based on sensor state when i_Fault clears
</verification>

<success_criteria>
- FB_HekBesturing.scl compiles without syntax errors
- All 9 states present in CASE statement (4 implemented, 5 as placeholders)
- Edge detection called once before CASE
- Timeout timer running for movement states
- First scan initialization sets correct state based on endstops
- HOMING moves toward DICHT (q_MS_Dicht=TRUE)
- FAULT auto-recovers when i_Fault clears
- q_AlarmKerk=FALSE only in IDLE_DICHT state
</success_criteria>

<output>
After completion, create `.planning/phases/03-state-machine/03-01-SUMMARY.md`
</output>
